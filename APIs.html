<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>APIs</title>
    <link rel="stylesheet" href="blog.css"> <!-- External stylesheet link -->
    <script src="script.js" defer></script> <!-- External JavaScript link -->

    <!-- style for code -->
    <style>
      code {
        background-color: #f4f4f4;
        padding: 4px 6px;
        border-radius: 5px;
        font-family: Consolas, monospace;
        font-size: 0.95em;
        color: #d6336c;
      }
    
      pre code {
        display: block;
        background-color: #f4f4f4;
        padding: 10px 15px;
        border-left: 4px solid #6c757d;
        overflow-x: auto;
        white-space: pre-wrap;
        border-radius: 6px;
        margin-bottom: 20px;
      }
    </style>

  </head>
  <body>
    <header>
      <h1>50 days of learning APIs</h1>
    </header>
    <h2>üìÖ Table of Contents</h2>
<ol>
  <li><a href="#day1">Day 1 - Introduction & Setup</a></li>
  <li><a href="#day2">Day 2 - Library website & API</a></li>
  <li><a href="#day3">Day 3 - Todo website & frontend and back-end API Integration</a></li>
  <li><a href="#day4">Day-4 - Permissions in Django REST Framework </a></li>
  <li><a href="#day5">Day-5 - User Authentication Methods in Django REST Framework </a></li>
</ol>


    <main>
      <article>
        <div class = "day" id="day1">
        <h2>Day-1 of Learning APIs</h2>
        <p>
            <time datetime="2025-04-28">April 28, 2025</time>
            <span> | </span>
            <span>Published by <strong>Sudip Shrestha(Author)</strong></span>
        </p>
        <section>
            <div class="content">
        <p>
            At the beginning of my journey to learn APIs, I explored various resources. 
            Mostly, I prefer to learn from books, which is why I searched online for a book and found 
            one titled <cite>Django for APIs</cite> <strong>by William S. Vincent</strong>. The reasons for me to  choose
            this book were:
            <ul>
                <li>I was already interested in Django and the scope of this book focused on Django.</li>
                <li>This book was specifically written to help beginners, addressing the lack of good resources available 
                for developers new to the Django REST Framework.</li>
                <li>It also includes many projects, and the author has made the code publicly available on GitHub (in case reader couldn't solve it)</li>
            </ul>
        </p>
        </section>
        <h3>LEARNING:</h3>
        <p>I found that in recent years an "API-first" approach has emerged as arguably the dominant paradigm in web 
        development. This approach involves formally seperating the back-end from the front-end.</p>
        <p>
            This paradigm of web-developement is "Future proof" because a backend API can be consumed by any JavaScript
            front-end(when the current front-end Framework eventually replaced by even newer ones in the years to come, the 
            back-end API can remain the same) not only that when one expand from web to mobile app the change is only  the 
            front-end part we don't have to redesign the whole backend architecture for the newer frontend by simply attaching 
            with the API.
        </p>

        <p>
          <h3><dfn>Serilization</dfn> </h3>
          A serializer translates data into a format that is easy to consume over the internet, typically JSON, 
          and is displayed at an API endpoint. 
        </p>
        <p>
          Why Serializers are Important?
          <ul>
          <li>APIs talk using JSON (or other formats).</li>

            <li>Django models are Python classes, not JSON.</li>

            <li>Serializers translate between these two worlds.</li>
          </ul>
        </p>
        
        <p>
          Types of Serializers in DRF

          <table>
            <tr>
              <th>Type</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>serializer.serilizers</td>
              <td>manually define field</td>
            </tr>
            <tr>
              <td>serializer.ModelSerilizer</td>
              <td>automatically define a field based on model</td>
            </tr>
          </table>
        </p>

        <p>
          <ul>What Happens</ul>  
          <li>Serialization	Python object ‚ûî JSON (send to client)</li>
          <li>Deserialization	JSON ‚ûî Python object (receive from client)</li>
          <li>Validation	Check if input data is valid (correct types, formats)</li>
          <li>Saving	If valid, create/update the model in the database</li>
        </p>

<p>
<h3><dfn>Generics</dfn></h3>
In Django REST Framework (DRF), generics are a set of views that provide common functionality for working with API endpoints. They simplify the creation of common API views, such as listing, creating, retrieving, updating, or deleting resources. DRF provides a range of generic views for these operations, allowing developers to quickly create RESTful APIs without writing repetitive code.

What are Generics in DRF?
Generics are class-based views that come pre-built with common behaviors for handling standard database operations like retrieving, updating, and deleting model instances. These views are built on top of DRF's APIView and provide convenient methods to simplify CRUD operations.

There are several generic views provided by DRF, and you can use them directly or extend them to meet your needs.

Types of Generics in DRF
Here are the main generic views available in DRF:

ListCreateAPIView:

Used for displaying a list of model instances and creating new ones.

Provides functionality for GET (list of objects) and POST (create new object).

RetrieveUpdateDestroyAPIView:

Used for retrieving, updating, and deleting individual model instances.

Provides functionality for GET (retrieve object), PUT/PATCH (update object), and DELETE (delete object).

<ol>
<li>ListAPIView:</li>

Used for displaying a list of model instances.

Provides functionality for the GET method (list objects), but doesn't support creating new objects.

<li>CreateAPIView:</li>

Used for creating new model instances.

Provides functionality for the POST method (create object), but doesn't support listing or modifying objects.

<li>RetrieveAPIView:</li>

Used for retrieving a single model instance.

Provides functionality for the GET method (retrieve object), but doesn't support creating or modifying objects.

<li>DestroyAPIView:</li>

Used for deleting a single model instance.

Provides functionality for the DELETE method (delete object), but doesn't support listing or creating objects.

<li>UpdateAPIView:</li>

Used for updating an existing model instance.

Provides functionality for PUT/PATCH (update object), but doesn't support listing or creating objects.</ol>
</p>
    </section>
    </div>
      </article>
</div>
<!-- Day2 -->
<div class= "day" id = "day2">
  <article>
    <h2>Day-2 of Learning APIs</h2>
        <p>
            <time datetime="2025-04-29">April 29, 2025</time>
            <span> | </span>
            <span>Published by <strong>Sudip Shrestha(Author)</strong></span>
        </p>
        <p>
          <section>
            <ol>
              <li><h3>Installed django rest-framework</h3></li>
              <pre><code>
pip install djangorestframework
                </code></pre>
            
                <li><h3>REST_FRAMEWORK Settings</h3></li>
                <br>
                  You can define a REST_FRAMEWORK dictionary in your settings.py file to customize how DRF behaves across your entire project.
                  <pre><code>
# settings.py
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],
# Optional: Pagination
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
}

                  </code>
                  </pre>
                  <h3>1. DEFAULT_PERMISSION_CLASSES</h3>
<p>This sets the default permission policy for your API views.</p>

<p><strong>Examples:</strong></p>

<ul>
  <li><code>'rest_framework.permissions.AllowAny'</code>: Anyone can access the API.</li>
  <li><code>'rest_framework.permissions.IsAuthenticated'</code>: Only authenticated users can access.</li>
  <li><code>'rest_framework.permissions.IsAdminUser'</code>: Only admin users can access.</li>
  <li><code>'rest_framework.permissions.DjangoModelPermissions'</code>: Uses Django's built-in model permissions.</li>
</ul>

<h3>2. DEFAULT_AUTHENTICATION_CLASSES</h3>
<p>This sets how DRF will <strong>authenticate</strong> users.</p>

<p><strong>Common options:</strong></p>
<ul>
  <li><code>'rest_framework.authentication.SessionAuthentication'</code>: Uses Django sessions (for browser users).</li>
  <li><code>'rest_framework.authentication.BasicAuthentication'</code>: HTTP Basic Auth (not safe for production unless HTTPS).</li>
  <li><code>'rest_framework.authentication.TokenAuthentication'</code>: For token-based auth (requires <code>rest_framework.authtoken</code>).</li>
  <li><code>'rest_framework_simplejwt.authentication.JWTAuthentication'</code>: For JWT tokens (third-party).</li>
</ul>

<h3>3. DEFAULT_PAGINATION_CLASS and PAGE_SIZE</h3>
<p>Used to paginate large lists of data automatically.</p>

<p><strong>Example:</strong></p>
<pre><code>'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
'PAGE_SIZE': 10</code></pre>

<p>This splits large API responses into pages. DRF adds navigation links like:</p>
<pre><code>{
  "next": "http://.../api/posts/?page=2",
  "previous": null,
  "results": [...]
}</code></pre>

<p><strong>Other pagination classes:</strong></p>
<ul>
  <li><code>LimitOffsetPagination</code></li>
  <li><code>CursorPagination</code></li>
</ul>

<h3>Optional Settings You Might Use Later:</h3>
<ul>
  <li>Throttle settings (limit requests per user/IP)</li>
  <li>Versioning (support multiple API versions)</li>
  <li>Exception handling customization</li>
  <li>Renderers (like JSON or browsable API UI)</li>
</ul>

<h2>Creating Views and Serializers for API</h2>

<h3>1. serializers.py</h3>
<p>In <code>serializers.py</code>, you'll define how the data will be serialized (converted into JSON format). A serializer is similar to a Django Form or ModelForm.</p>

<pre><code>
# api/serializers.py
from rest_framework import serializers
from .models import Post

class PostSerializer(serializers.ModelSerializer):
    class Meta:
        model = Post
        fields = '__all__'  # Serialize all fields of the Post model
</code></pre>

<p><strong>Explanation:</strong></p>
<ul>
  <li><code>ModelSerializer</code>: This is the most common serializer that automatically generates fields based on the Django model.</li>
  <li><code>fields = '__all__'</code>: This indicates that you want to serialize all the fields in the model. You can also specify specific fields, e.g., <code>['title', 'content']</code>.</li>
</ul>

<h3>2. views.py</h3>
<p>In <code>views.py</code>, you'll define the API views. DRF provides several ways to create views, including <code>APIView</code>, <code>viewsets</code>, and <code>generic views</code>.</p>

<h4>Option 1: Using ViewSets (Recommended for simplicity)</h4>
<p><code>ViewSets</code> allow you to handle basic CRUD operations automatically.</p>

<pre><code>
# api/views.py
from rest_framework import viewsets
from .models import Post
from .serializers import PostSerializer

class PostViewSet(viewsets.ModelViewSet):
    queryset = Post.objects.all()  # Query to get all posts
    serializer_class = PostSerializer  # Specify the serializer to use
</code></pre>

<ul>
  <li><code>ModelViewSet</code>: Automatically provides implementations for CRUD operations (Create, Read, Update, Delete).</li>
</ul>

<h4>Option 2: Using APIView (Custom behavior)</h4>
<p>If you need more custom behavior, you can use <code>APIView</code> to manually define the logic for each method (GET, POST, PUT, DELETE).</p>

<pre><code>
# api/views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Post
from .serializers import PostSerializer

class PostList(APIView):
    def get(self, request, format=None):
        posts = Post.objects.all()  # Fetch all posts
        serializer = PostSerializer(posts, many=True)  # Serialize the data
        return Response(serializer.data)  # Return as JSON

    def post(self, request, format=None):
        serializer = PostSerializer(data=request.data)  # Get data from request
        if serializer.is_valid():
            serializer.save()  # Save to database
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
</code></pre>

<ul>
  <li><code>get()</code>: Retrieves data.</li>
  <li><code>post()</code>: Creates new data.</li>
</ul>

<h3>3. URLs Setup</h3>
<p>Once your views are defined, you need to wire them up in the URLs file (<code>urls.py</code>).</p>

<h4>Using ViewSet (DRF Router)</h4>
<p>With <code>viewsets</code>, DRF provides a <code>router</code> that automatically maps the views to URLs.</p>

<pre><code>
# api/urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import PostViewSet

router = DefaultRouter()
router.register(r'posts', PostViewSet)  # Register PostViewSet for 'posts' endpoint

urlpatterns = [
    path('', include(router.urls)),  # Includes all routes from the router
]
</code></pre>

<h4>Using APIView</h4>
<p>If you're using <code>APIView</code>, manually create URL mappings.</p>

<pre><code>
# api/urls.py
from django.urls import path
from .views import PostList

urlpatterns = [
    path('posts/', PostList.as_view(), name='post-list'),  # Map to PostList class
]
</code></pre>

<h3>4. Example of Testing the API</h3>
<p>Once everything is set up, you can test the API by running the development server:</p>

<pre><code>
python manage.py runserver
</code></pre>

<p>Visit <code>http://127.0.0.1:8000/api/posts/</code> to see the list of posts (if you're using <code>PostViewSet</code>) or <code>http://127.0.0.1:8000/api/posts</code> for the <code>APIView</code>.</p>

            </ol>

                </section>
        </p>
        
  </article>
</div>

<div class="day" id ="day3"><h2>Day-3 of Learning APIs </h2></div>
<article><p>
  <time datetime="2025-04-30">April,29 2025</time>
  <span> | </span>
  <span>Published by <strong>Sudip Shrestha(Author)</strong></span>
</p>
<section>
  <h2>What I Learned About Django REST Framework (DRF) and API Integration</h2>
  <ul>
    <li><strong>DRF returns data in JSON format</strong><br>
      Example:
      <pre><code>[
  { "id": 1, "title": "Task 1", "body": "Learn Django" },
  { "id": 2, "title": "Task 2", "body": "Learn React" }
]</code></pre>
    </li>

    <li><strong>Django automatically adds an <code>id</code> field</strong><br>
      This helps React identify each item using a unique <code>key</code> when rendering a list.
    </li>

    <li><strong>You use HTTP GET to access data from DRF</strong><br>
      Called using:
      <code>axios.get('http://127.0.0.1:8000/api/')</code>
    </li>

    <li><strong>API endpoint design matters</strong><br>
      Keeping it clean like <code>/api/</code> helps frontend-backend communication.
    </li>

    <li><strong>CORS must be enabled</strong><br>
      React (on port 3000) and Django (on 8000) are separate origins, so CORS must be set using:
      <code>django-cors-headers</code>
    </li>

    <li><strong>API integration keeps content dynamic</strong><br>
      React doesn't hardcode data ‚Äî it fetches the live list from Django.
    </li>

    <li><strong>DRF (backend) and React (frontend) work together</strong><br>
      DRF handles logic/data, React handles UI ‚Äî and APIs connect them.
    </li>
  </ul>  
</section>

<section>
  <h2>What is CORS?</h2>
  <p><strong>CORS</strong> (Cross-Origin Resource Sharing) is a security feature enforced by web browsers. It determines whether a web application running on one origin (domain) is permitted to request resources from a different origin.</p>

  <p><strong>Purpose:</strong> Prevent unauthorized cross-domain requests for security.</p>

  <p><strong>Common Headers:</strong></p>
  <ul>
    <li><code>Access-Control-Allow-Origin</code></li>
    <li><code>Access-Control-Allow-Methods</code></li>
    <li><code>Access-Control-Allow-Headers</code></li>
  </ul>

  <p><strong>Example:</strong> A frontend hosted on <code>https://example.com</code> trying to access data from <code>https://api.othersite.com</code> requires CORS headers from the API server.</p>

  <hr>

  <h2>How to Handle CORS in Django</h2>

  <p>Use the <code>django-cors-headers</code> package:</p>

  <h3>1. Install the package</h3>
  <pre><code>pip install django-cors-headers</code></pre>

  <h3>2. Add to <code>INSTALLED_APPS</code> in <code>settings.py</code></h3>
  <pre><code>'corsheaders',</code></pre>

  <h3>3. Add middleware (near the top)</h3>
  <pre><code>'corsheaders.middleware.CorsMiddleware',</code></pre>

  <h3>4. Allow all origins (for development)</h3>
  <pre><code>CORS_ALLOW_ALL_ORIGINS = True</code></pre>

  <h3>5. Or allow specific origins (recommended for production)</h3>
  <pre><code>
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "https://your-frontend.com",
]
  </code></pre>

  <p><strong>Note:</strong> Only browser-based requests are affected by CORS. Server-to-server requests don't require it.</p>
</section>
</article>

<div class= "day" id = "day4">
  <article>
    <h2>Day-4 of Learning APIs</h2>
        <p>
            <time datetime="2025-05-01">May 1, 2025</time>
            <span> | </span>
            <span>Published by <strong>Sudip Shrestha(Author)</strong></span>
        </p>
      
        <section>
          <p>
              <h1>Today I Learned: Custom Permissions in Django REST Framework</h1>
            
              <p>
                Django REST Framework ships with several out-of-the-box permission settings that we can use to secure our API.
                These permissions can be applied at different levels:
              </p>
              <ul>
                <li><strong>Project-level</strong>: Set globally via <code>settings.py</code></li>
                <li><strong>View-level</strong>: Applied to specific views or viewsets</li>
                <li><strong>Model-level</strong>: Enforced per-object using custom logic</li>
              </ul>
            
              <p>
                Today, I learned how to create my own custom permission for my current project ‚Äî a <strong>Blog site</strong>.
                I implemented a permission that ensures <strong>only the author</strong> of a blog post has the ability to
                update or delete it.
              </p>
            
              <h2>What This Means</h2>
              <p>
                By writing a custom permission class and attaching it to my viewset, I've added a layer of security to make sure
                that users cannot modify blog posts that they don't own. This enhances data integrity and user accountability in my app.
              </p>
            
          </p>
        </section>

        <section>
          <h1>Custom Permissions in Django REST Framework (DRF)</h1>

          <h2>What Are Custom Permissions?</h2>
          <p>
            Custom permissions in DRF let you define fine-grained access control for your API endpoints,
            going beyond the built-in permissions like <code>IsAuthenticated</code> or <code>IsAdminUser</code>.
          </p>
        
          <h2>How BasePermission Works</h2>
          <ul>
            <li><strong>BasePermission</strong> is an abstract class you subclass to create custom permissions.</li>
            <li><code>has_permission(self, request, view)</code>: checks general (view-level) access.</li>
            <li><code>has_object_permission(self, request, view, obj)</code>: checks object-specific access (e.g., for retrieve/update/delete).</li>
            <li>DRF calls <code>has_permission()</code> first, then <code>has_object_permission()</code> if the view is detail-based.</li>
          </ul>
        
          <h2>How to Create a Custom Permission</h2>
          <pre><code>
        # app_name/permissions.py
        from rest_framework.permissions import BasePermission
        
        class IsOwnerOrReadOnly(BasePermission):
            def has_object_permission(self, request, view, obj):
                if request.method in ['GET', 'HEAD', 'OPTIONS']:
                    return True
                return obj.owner == request.user
          </code></pre>
        
          <h2>How to Use a Custom Permission in a View</h2>
          <pre><code>
        # app_name/views.py
        from rest_framework import viewsets
        from .models import Article
        from .serializers import ArticleSerializer
        from .permissions import IsOwnerOrReadOnly
        
        class ArticleViewSet(viewsets.ModelViewSet):
            queryset = Article.objects.all()
            serializer_class = ArticleSerializer
            permission_classes = [IsOwnerOrReadOnly]
          </code></pre>
        
          <h2>Combining With Built-in Permissions</h2>
          <pre><code>
        from rest_framework.permissions import IsAuthenticated
        
        class ArticleViewSet(viewsets.ModelViewSet):
            ...
            permission_classes = [IsAuthenticated, IsOwnerOrReadOnly]
          </code></pre>
        
          <h2>Optional: Set as Global Default in settings.py</h2>
          <pre><code>
        REST_FRAMEWORK = {
            'DEFAULT_PERMISSION_CLASSES': [
                'rest_framework.permissions.IsAuthenticated',
                'your_app.permissions.IsOwnerOrReadOnly',
            ]
        }
          </code></pre>
        
          <p>You can build more advanced permissions using custom logic inside the permission class.</p>
        </section>


<!-- Day5 -->

      <div class = "day" id="day5">
        <h2>Day-5 of Learning APIs</h2>
        <p>
            <time datetime="2025-05-02">May 2, 2025</time>
            <span> | </span>
            <span>Published by <strong>Sudip Shrestha(Author)</strong></span>
        </p>
        <section>
          <h2>üîê Introduction to User Authentication</h2>
          <p>
            <strong>User authentication</strong> is the process of verifying the identity of a user who is trying to access a system. 
            It ensures that only registered and authorized users can access certain features, data, or services within a web or mobile application.
          </p>
          <p>
            Since <strong>HTTP is stateless</strong>, servers cannot remember user sessions across multiple requests. 
            To overcome this, authentication mechanisms are used to identify users in each interaction with the server.
          </p>
          <p>
            Common user authentication actions include:
          </p>
          <ul>
            <li><strong>Sign Up</strong> ‚Äì Creating a new user account</li>
            <li><strong>Log In</strong> ‚Äì Verifying user credentials to gain access</li>
            <li><strong>Log Out</strong> ‚Äì Ending an authenticated session</li>
          </ul>
          <p>
            Web applications and APIs support various authentication methods such as 
            <em>Basic Auth</em>, <em>Session Auth</em>, <em>Token Auth</em>, <em>JWT</em>, and <em>OAuth2</em>, 
            each with their own use cases and security considerations.
          </p>
        </section>
        

          <h1>User Authentication Methods in Django REST Framework</h1>
        
          <section>
            <h2>1. Basic Authentication</h2>
            <p><strong>Concept:</strong> Sends the username and password in every HTTP request using the <code>Authorization</code> header.</p>
            <h3>Workflow:</h3>
            <ol>
              <li>Client sends a request.</li>
              <li>Server responds with <code>401 Unauthorized</code>.</li>
              <li>Client resends the request with encoded credentials.</li>
              <li>Server checks and responds with <code>200 OK</code> or <code>403 Forbidden</code>.</li>
            </ol>
            <p><strong>Pros:</strong> Simple setup.</p>
            <p><strong>Cons:</strong> Insecure unless HTTPS is used. Credentials sent on every request.</p>
            <pre><code>REST_FRAMEWORK = {
            'DEFAULT_AUTHENTICATION_CLASSES': [
                'rest_framework.authentication.BasicAuthentication',
            ]
        }</code></pre>
          </section>
        
          <section>
            <h2>2. Session Authentication</h2>
            <p><strong>Concept:</strong> Credentials are sent once; then a session ID is stored in a cookie for further requests.</p>
            <h3>Workflow:</h3>
            <ol>
              <li>User logs in with username and password.</li>
              <li>Server creates a session object and returns a session ID cookie.</li>
              <li>Browser sends this cookie on every request.</li>
              <li>Server validates the session ID and grants access.</li>
            </ol>
            <p><strong>Pros:</strong> More secure and efficient than Basic Auth for web apps.</p>
            <p><strong>Cons:</strong> Not suitable for APIs across multiple devices or clients.</p>
            <pre><code>REST_FRAMEWORK = {
            'DEFAULT_AUTHENTICATION_CLASSES': [
                'rest_framework.authentication.SessionAuthentication',
            ]
        }</code></pre>
          </section>
        
          <section>
            <h2>3. Token Authentication</h2>
            <p><strong>Concept:</strong> User gets a token after login and includes it in the header of every request.</p>
            <h3>Workflow:</h3>
            <ol>
              <li>User logs in with credentials.</li>
              <li>Server returns a token.</li>
              <li>Client sends token with each request using <code>Authorization: Token &lt;token&gt;</code>.</li>
            </ol>
            <p><strong>Pros:</strong> Stateless, secure, works for APIs across platforms.</p>
            <p><strong>Cons:</strong> Requires token storage and revocation handling.</p>
          </section>
        
          <section>
            <h2>4. JWT (JSON Web Token)</h2>
            <p><strong>Concept:</strong> A self-contained token with user info and expiry, sent with every request.</p>
            <h3>Workflow:</h3>
            <ol>
              <li>User logs in and receives a JWT.</li>
              <li>Client sends JWT in <code>Authorization: Bearer &lt;jwt&gt;</code> header.</li>
              <li>Server verifies and decodes the token.</li>
            </ol>
            <p><strong>Pros:</strong> Stateless, scalable, secure with expiry and compact structure.</p>
            <p><strong>Cons:</strong> Cannot be revoked easily without extra tools.</p>
          </section>
        
          <section>
            <h2>5. OAuth 2.0</h2>
            <p><strong>Concept:</strong> User logs in through a third-party (like Google), receives a token used to access protected resources.</p>
            <h3>Workflow:</h3>
            <ol>
              <li>User authenticates through a provider (Google, Facebook, etc.).</li>
              <li>Provider returns an access token.</li>
              <li>Client uses this token to authenticate or fetch data.</li>
            </ol>
            <p><strong>Pros:</strong> Very secure, no handling of credentials, suitable for social logins.</p>
            <p><strong>Cons:</strong> Complex to set up, external dependency.</p>
          </section>
        
          <section>
            <h2>Summary Table</h2>
            <table border="1">
              <thead>
                <tr>
                  <th>Authentication Type</th>
                  <th>Stateful?</th>
                  <th>Secure?</th>
                  <th>Use Case</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Basic Auth</td>
                  <td>No</td>
                  <td>Only with HTTPS</td>
                  <td>Testing or internal APIs</td>
                </tr>
                <tr>
                  <td>Session Auth</td>
                  <td>Yes</td>
                  <td>Yes</td>
                  <td>Django web apps</td>
                </tr>
                <tr>
                  <td>Token Auth</td>
                  <td>No</td>
                  <td>Yes</td>
                  <td>APIs across platforms</td>
                </tr>
                <tr>
                  <td>JWT</td>
                  <td>No</td>
                  <td>Yes (with expiry)</td>
                  <td>Modern APIs</td>
                </tr>
                <tr>
                  <td>OAuth 2.0</td>
                  <td>No</td>
                  <td>Yes</td>
                  <td>Social login, external APIs</td>
                </tr>
              </tbody>
            </table>
          </section>

        
</main>
      <div style="text-align: center;"><h3>***HAPPY ENDING***</h3></div>

    <footer>
      <p>&copy; 2025 sudip shrestha</p>
    </footer>
  </body>
</html>
