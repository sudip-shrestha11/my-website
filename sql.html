<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SQL Journey - Lesson 1 & 2</title>
  <meta name="description" content="SQL tutorial covering SELECT, DISTINCT, LIMIT and data basics.">
  <meta name="keywords" content="SQL, database, SELECT, DISTINCT, LIMIT, tutorial">
  <meta name="author" content="Your Name">
  <style>
    body {
      font-family: sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: auto;
      padding: 2em;
    }
    h1, h2, h3 {
      color: #333;
    }
    pre.code {
      background: #f4f4f4;
      border-left: 4px solid #007acc;
      padding: 1em;
      overflow-x: auto;
      white-space: pre-wrap;
      font-family: monospace;
    }
  </style>
  <nav id="toc">
    <h2>Table of Contents</h2>
    <ul>
      <li><a href="#lesson-1">Lesson 1: Introduction to Databases</a></li>
      <li><a href="#lesson-2">Lesson 2: SELECT Basics</a></li>
      <li><a href="#lesson-3">Lesson 3: Sorting Retrieved Data</a></li>
      <li><a href="#lesson-4">Lesson 4: Filtering Data</a></li>
      <li><a href="#lesson-5">Lesson 5: Advanced Data Filtering</a></li>
      <li><a href="#lesson-6">Lesson 6: Using Wildcard Filtering</a></li>
      <li><a href="#lesson-7">Lesson 7: Creating Calculated Fields</a></li>
      <li><a href="#lesson-8">Lesson 8: Using Data Manipulation Functions</a></li>
      <li><a href="#lesson-9">Lesson 9: Creating Calculated Fields</a></li>
      <li><a href="#lesson-10">Lesson 10: Grouping Data</a></li>
      <li><a href="#lesson-11">Lesson 11: Working with Subqueries</a></li>
      <li><a href="#Problem and soultion on Joins">Problem and soultion on Joins</a></li>
      <li><a href="#Lesson 14: combining queries">Lesson 14: Combining Queries</a></li>
      <li><a href="#lesson 15:inserting data">lesson 15: Inserting Data</a></li>
      <li><a href="#Lesson 16: Updating and Deleting Data">Lesson 16: Updating and Deleting Data</a></li>
      <li><a href="#Lesson 17: Creating and Manipulating Tables">Lesson 17: Creating and Manipulating Tables</a></li>
      <li><a href="#Understanding Views">Lesson 18: Understanding Views</a></li>
      <li><a href="#lesson19">Lesson 19: Using Stored Procedures<a></li>
      <li><a href="#lesson20">Lesson 20: cursors<a></li> 
    

      Understanding Views
      
     
    </ul>
  </nav>
  

</head>
<body>
    <h1>SQL Journey - Lesson 1 & 2</h1>
  
    <h2 id="lesson-1">Lesson 1</h2>
    <p><strong>Database</strong><br>
    A container (usually a file or set of files) to store organized data.</p>
  
    <p><strong>Table</strong><br>
    A structured list of data of a specific type.</p>
  
    <p><strong>Schema</strong><br>
    Information about database and table layout and properties.</p>
  
    <p><strong>Column</strong><br>
    A single field in a table. All tables are made up of one or more columns.</p>
  
    <p><strong>Tip: Breaking Up Data</strong><br>
    It's important to break data into multiple columns correctly (e.g., city, state, ZIP). If combined, sorting/filtering becomes hard. Choose granularity based on needs. For example, house number and street name are usually kept together unless you need to sort by street name.</p>
  
    <p><strong>Datatype</strong><br>
    The kind of data allowed in a column, restricting or permitting specific values.</p>
  
    <p><strong>Row</strong><br>
    A record in a table. Though ‚Äúrecord‚Äù and ‚Äúrow‚Äù are interchangeable, ‚Äúrow‚Äù is more technically correct.</p>
  
    <p><strong>Primary key</strong><br>
    A column (or set of columns) that uniquely identifies every row in a table.</p>
  
    <p><strong>Tip: Always Define Primary Keys</strong><br>
    Primary keys are optional but recommended for reliable data manipulation and maintenance.</p>
  
    <ul>
      <li>No duplicate primary key values.</li>
      <li>Primary key columns cannot be NULL.</li>
      <li>Values shouldn‚Äôt be changed or reused.</li>
    </ul>
  
    <p>Primary keys can consist of multiple columns. Together, their values must be unique.</p>
  
    <p><strong>What is SQL?</strong><br>
    SQL (Structured Query Language) is used to communicate with databases. It is simple but powerful, supported by most DBMS, and uses a small number of keywords.</p>
  
    <h2 id="lesson-2">Lesson 2</h2>
    <p>This lesson introduces the SELECT statement to retrieve one or more columns of data from a table.</p>
  
    <h3>Input</h3>
    <pre class="code"><code>SELECT prod_name
  FROM Products;</code></pre>
  
    <h3>Output</h3>
    <pre class="code"><code>prod_name
  Fish bean bag toy
  Bird bean bag toy
  Rabbit bean bag toy
  8 inch teddy bear
  12 inch teddy bear
  18 inch teddy bear
  Raggedy Ann
  King doll
  Queen doll</code></pre>
  
    <p><strong>Tip: Terminating Statements</strong><br>
    Multiple SQL statements should be separated by semicolons. Some DBMS require it; others don't. Adding it won't hurt.</p>
  
    <p><strong>Tip: SQL Case Sensitivity</strong><br>
    SQL keywords are case-insensitive. Best practice: use uppercase for SQL and lowercase for names.</p>
  
    <p><strong>Tip: Use of White Space</strong><br>
    White space is ignored. You can write SQL on one line or many. Example:</p>
  
    <pre class="code"><code>SELECT prod_name FROM Products;
  SELECT
  prod_name
  FROM
  Products;</code></pre>
  
    <p>To retrieve multiple columns:</p>
  
    <h3>Input</h3>
    <pre class="code"><code>SELECT prod_id, prod_name, prod_price
  FROM Products;</code></pre>
  
    <p><strong>Tip: Take Care with Commas</strong><br>
    Use commas between column names, but not after the last column name.</p>
  
    <p><strong>Note: Presentation of Data</strong><br>
    SQL returns raw, unformatted data. Formatting is handled by the application layer, not SQL.</p>
  
    <p>To retrieve all columns:</p>
  
    <h3>Input</h3>
    <pre class="code"><code>SELECT *
  FROM Products;</code></pre>
  
    <p><strong>Caution: Using Wildcards</strong><br>
    Using * to select all columns may reduce performance.</p>
  
    <p>To get distinct rows:</p>
  
    <h3>Input</h3>
    <pre class="code"><code>SELECT vend_id
  FROM Products;</code></pre>
  
    <h3>Output</h3>
    <pre class="code"><code>vend_id
  BRS01
  BRS01
  BRS01
  DLL01
  DLL01
  DLL01
  DLL01
  FNG01
  FNG01</code></pre>
  
    <p>To eliminate duplicates:</p>
  
    <h3>Input</h3>
    <pre class="code"><code>SELECT DISTINCT vend_id
  FROM Products;</code></pre>
  
    <h3>Output</h3>
    <pre class="code"><code>vend_id
  BRS01
  DLL01
  FNG01</code></pre>
  
    <p><strong>Caution: Can‚Äôt Be Partially DISTINCT</strong><br>
    DISTINCT applies to all selected columns, not just the first one.</p>
  
    <p>To limit rows:</p>
  
    <h3>Input</h3>
    <pre class="code"><code>SELECT prod_name
  FROM Products
  LIMIT 5;</code></pre>
  
    <p>To skip rows and limit count:</p>
  
    <h3>Input</h3>
    <pre class="code"><code>SELECT prod_name
  FROM Products
  LIMIT 5 OFFSET 5;</code></pre>
  
    <h3>Output</h3>
    <pre class="code"><code>prod_name
  Rabbit bean bag toy
  Raggedy Ann
  King doll
  Queen doll</code></pre>
  
    <p><strong>Analysis</strong><br>
    LIMIT 5 OFFSET 5 skips the first 5 rows and returns the next 5. Only 4 rows are returned here because the table had 9 products.</p>
  
    <p><strong>Caution: Row 0</strong><br>
    The first row is row 0, not row 1. So OFFSET 1 gets the second row.</p>
  
    <p><strong>Tip: MySQL & MariaDB Shortcut</strong><br>
    You can write LIMIT 4 OFFSET 3 as LIMIT 3,4 in these databases.</p>


        <h2 id="lesson-3">Lesson 3: Sorting Retrieved Data</h2>
      
        <p>In this lesson, you will learn how to use the SELECT statement‚Äôs ORDER BY clause to sort retrieved data as needed.</p>
      
        <p>By default, SQL does not guarantee any specific order of returned rows. To control order, you must use ORDER BY.</p>
      
        <h3>Input</h3>
        <pre class="code"><code>SELECT prod_name
      FROM Products
      ORDER BY prod_name;</code></pre>
      
        <p><strong>Analysis</strong><br>
        This statement sorts results by the prod_name column. Without ORDER BY, the order of results is unpredictable.</p>
      
        <p><strong>Caution: Position of ORDER BY Clause</strong><br>
        ORDER BY must be the last clause in a SELECT statement. Placing it elsewhere will cause errors.</p>
      
        <p><strong>Tip: Sorting by Nonselected Columns</strong><br>
        You can sort by columns that are not included in the SELECT list.</p>
      
        <h3>Sorting by Multiple Columns</h3>
        <p>You can sort by more than one column. For example, by price and then by name.</p>
      
        <h3>Input</h3>
        <pre class="code"><code>SELECT prod_id, prod_price, prod_name
      FROM Products
      ORDER BY prod_price, prod_name;</code></pre>
      
        <h3>Output</h3>
        <pre class="code"><code>prod_id     prod_price     prod_name
      BNBG02      3.49           Bird bean bag toy
      BNBG01      3.49           Fish bean bag toy
      BNBG03      3.49           Rabbit bean bag toy
      RGAN01      4.99           Raggedy Ann
      BR01        5.99           8 inch teddy bear
      BR02        8.99           12 inch teddy bear
      RYL01       9.49           King doll
      RYL02       9.49           Queen doll
      BR03        11.99          18 inch teddy bear</code></pre>
      
        <h3>Sorting by Column Position</h3>
        <p>You can also sort using the position of columns in the SELECT list instead of column names.</p>
      
        <h3>Input</h3>
        <pre class="code"><code>SELECT prod_id, prod_price, prod_name
      FROM Products
      ORDER BY 2, 3;</code></pre>
      
        <h3>Output</h3>
        <pre class="code"><code>(Same as previous output)</code></pre>
      
        <p><strong>Analysis</strong><br>
        ORDER BY 2 sorts by the second column (prod_price), and ORDER BY 2, 3 sorts by price then name. This can be risky if column positions change.</p>
      
        <p>‚ö†Ô∏è Downsides of using column positions:</p>
        <ul>
          <li>Higher risk of mistakes if columns are rearranged</li>
          <li>Not usable if the column isn‚Äôt in SELECT</li>
        </ul>
      
        <h3>Specifying Sort Direction</h3>
        <p>By default, sorting is ascending (A‚ÄìZ). To sort in descending order (Z‚ÄìA), use the DESC keyword.</p>
      
        <h3>Input</h3>
        <pre class="code"><code>SELECT prod_id, prod_price, prod_name
      FROM Products
      ORDER BY prod_price DESC;</code></pre>
      
        <h3>Output</h3>
        <pre class="code"><code>prod_id     prod_price     prod_name
      BR03        11.99          18 inch teddy bear
      RYL01       9.49           King doll
      RYL02       9.49           Queen doll
      BR02        8.99           12 inch teddy bear
      BR01        5.99           8 inch teddy bear
      RGAN01      4.99           Raggedy Ann</code></pre>
      
        <p>Sorting by multiple columns in descending order:</p>
      
        <h3>Input</h3>
        <pre class="code"><code>SELECT prod_id, prod_price, prod_name
      FROM Products
      ORDER BY prod_price DESC, prod_name;</code></pre>
      
        <p><strong>Note:</strong> DESC is short for DESCENDING. ASC (or ASCENDING) is rarely needed because it's the default.</p>
      
        <p><strong>Tip: Case-Sensitivity and Sort Orders</strong><br>
        When sorting text, whether A = a depends on database collation. Most DBMSs treat A and a the same by default, but this can be configured. If you need a special sort order (e.g., for non-English characters), ORDER BY might not be enough, and you'll need DBA help.</p>
        
            <h2 id="lesson-4">Lesson 4: Filtering Data</h2>
          
            <p>In this lesson, you will learn how to use the SELECT statement‚Äôs WHERE clause to specify search conditions.</p>
          
            <h3>Using the WHERE Clause</h3>
            <p>Database tables usually contain large amounts of data, but you seldom need to retrieve all the rows. More often, you'll want a subset of the data for a specific task. You define this using the WHERE clause, placed after the FROM clause.</p>
          
            <h3>Input</h3>
            <pre class="code"><code>SELECT prod_name, prod_price
          FROM Products
          WHERE prod_price = 3.49;</code></pre>
          
            <p><strong>Analysis</strong><br>
            This query returns only the rows where prod_price is 3.49.</p>
          
            <h3>Output</h3>
            <pre class="code"><code>prod_name              prod_price
          Fish bean bag toy      3.49
          Bird bean bag toy      3.49
          Rabbit bean bag toy    3.49</code></pre>
          
            <p><strong>Tip: SQL vs Application Filtering</strong><br>
            Although filtering can be done in the application layer, it's best done in SQL. Filtering in code causes performance issues and network overhead. Let the database do the filtering.</p>
          
            <p><strong>Caution: WHERE Clause Position</strong><br>
            If you're using both WHERE and ORDER BY, make sure WHERE comes first.</p>
          
            <h3>Checking for Nonmatches</h3>
          
            <h3>Input</h3>
            <pre class="code"><code>SELECT vend_id, prod_name
          FROM Products
          WHERE vend_id &lt;&gt; 'DLL01';</code></pre>
          
            <p><strong>Tip: When to Use Quotes</strong><br>
            Use single quotes around string values (like vendor IDs). Do not quote numeric values.</p>
          
            <h3>Checking for a Range of Values</h3>
          
            <h3>Input</h3>
            <pre class="code"><code>SELECT prod_name, prod_price
          FROM Products
          WHERE prod_price BETWEEN 5 AND 10;</code></pre>
          
            <h3>Output</h3>
            <pre class="code"><code>prod_name              prod_price
          8 inch teddy bear      5.99
          12 inch teddy bear     8.99
          King doll              9.49
          Queen doll             9.49</code></pre>
          
            <p><strong>Analysis</strong><br>
            BETWEEN requires two values and includes both ends of the range.</p>
          
            <h3>Checking for NULL Values</h3>
          
            <h3>Input</h3>
            <pre class="code"><code>SELECT prod_name
          FROM Products
          WHERE prod_price IS NULL;</code></pre>
          
            <p><strong>Caution: NULL and Non-matches</strong><br>
            NULLs do not behave like regular values. A condition like "WHERE column &lt;&gt; value" will not include rows where the column is NULL. Always check NULL handling carefully.</p>
          
            <h3>Summary</h3>
            <p>In this lesson, you learned how to use the WHERE clause to filter data by equality, inequality, ranges, and NULL values.</p>
          
        
                <h2 id="lesson-5">Lesson 5: Advanced Data Filtering</h2>
              
                <p>In this lesson, you‚Äôll learn how to combine WHERE clauses to create powerful and sophisticated search conditions. You‚Äôll also learn how to use the NOT and IN operators.</p>
              
                <h3>Combining WHERE Clauses</h3>
                <p>Until now, you‚Äôve filtered using a single condition. SQL allows combining multiple conditions using AND or OR operators.</p>
              
                <p><strong>Operator:</strong> A special keyword used to join or alter clauses in a WHERE clause (e.g., AND, OR).</p>
              
                <h3>Using the AND Operator</h3>
              
                <h4>Input</h4>
                <pre class="code"><code>SELECT prod_id, prod_price, prod_name
              FROM Products
              WHERE vend_id = 'DLL01' AND prod_price <= 4;</code></pre>
              
                <p><strong>Analysis</strong><br>
                This returns products from vendor DLL01 with a price less than or equal to $4. Both conditions must be true for a row to be included.</p>
              
                <p><strong>AND:</strong> Returns rows matching all specified conditions.</p>
              
                <h3>Using the OR Operator</h3>
              
                <h4>Input</h4>
                <pre class="code"><code>SELECT prod_name, prod_price
              FROM Products
              WHERE vend_id = 'DLL01' OR vend_id = 'BRS01';</code></pre>
              
                <p><strong>Analysis</strong><br>
                This returns products from either DLL01 or BRS01. Only one condition needs to match for inclusion.</p>
              
                <h4>Output</h4>
                <pre class="code"><code>prod_name              prod_price
              Fish bean bag toy      3.49
              Bird bean bag toy      3.49
              Rabbit bean bag toy    3.49
              8 inch teddy bear      5.99
              12 inch teddy bear     8.99
              18 inch teddy bear     11.99
              Raggedy Ann            4.99</code></pre>
              
                <p><strong>OR:</strong> Returns rows matching any of the specified conditions.</p>
              
                <h3>Understanding Order of Evaluation</h3>
                <p>SQL evaluates AND before OR. Misplaced conditions can produce unexpected results. Use parentheses to control logic.</p>
              
                <h4>Incorrect Input</h4>
                <pre class="code"><code>SELECT prod_name, prod_price
              FROM Products
              WHERE vend_id = 'DLL01' OR vend_id = 'BRS01'
              AND prod_price >= 10;</code></pre>
              
                <h4>Output</h4>
                <pre class="code"><code>prod_name              prod_price
              Fish bean bag toy      3.49
              Bird bean bag toy      3.49
              Rabbit bean bag toy    3.49
              18 inch teddy bear     11.99
              Raggedy Ann            4.99</code></pre>
              
                <p><strong>Analysis</strong><br>
                The AND takes precedence, so this returns all DLL01 products (any price) and BRS01 products with price ‚â• 10. This is likely not what was intended.</p>
              
                <h4>Corrected Input</h4>
                <pre class="code"><code>SELECT prod_name, prod_price
              FROM Products
              WHERE (vend_id = 'DLL01' OR vend_id = 'BRS01')
              AND prod_price >= 10;</code></pre>
              
                <h4>Output</h4>
                <pre class="code"><code>prod_name              prod_price
              18 inch teddy bear     11.99</code></pre>
              
                <p><strong>Tip: Using Parentheses in WHERE Clauses</strong><br>
                Always use parentheses when mixing AND and OR conditions. It avoids ambiguity and logical mistakes.</p>
              
                <h3>Using the IN Operator</h3>
              
                <h4>Input</h4>
                <pre class="code"><code>SELECT prod_name, prod_price
              FROM Products
              WHERE vend_id IN ('DLL01', 'BRS01')
              ORDER BY prod_name;</code></pre>
              
                <h4>Output</h4>
                <pre class="code"><code>prod_name              prod_price
              12 inch teddy bear     8.99
              18 inch teddy bear     11.99
              8 inch teddy bear      5.99
              Bird bean bag toy      3.49
              Fish bean bag toy      3.49
              Rabbit bean bag toy    3.49
              Raggedy Ann            4.99</code></pre>
              
                <p><strong>Analysis</strong><br>
                IN is a cleaner, more efficient alternative to multiple OR statements.</p>
              
                <p><strong>Why use IN?</strong></p>
                <ul>
                  <li>Cleaner syntax with long lists</li>
                  <li>Better control when combining with AND/OR</li>
                  <li>Typically faster than multiple ORs</li>
                  <li>Can be combined with subqueries</li>
                </ul>
              
                <h3>Using the NOT Operator</h3>
              
                <h4>Input</h4>
                <pre class="code"><code>SELECT prod_name
              FROM Products
              WHERE NOT vend_id = 'DLL01'
              ORDER BY prod_name;</code></pre>
              
                <p><strong>Analysis</strong><br>
                NOT negates the condition following it. Here, it returns all rows where vend_id is not DLL01.</p>
              
                <p><strong>Why use NOT?</strong><br>
                While basic use cases don‚Äôt benefit much, NOT is powerful when combined with IN, BETWEEN, or EXISTS.</p>
              
                <p><strong>Note: NOT in MariaDB</strong><br>
                MariaDB supports NOT with IN, BETWEEN, and EXISTS. Some DBMSs may limit this to just a few clause types.</p>
              
                <h3>Summary</h3>
                <p>This lesson taught how to combine WHERE clauses using AND, OR, and NOT, and how to control logic with parentheses. You also learned the use and advantages of the IN operator.</p>
            
                
                    <h2 id="lesson-6">Lesson 6: Using Wildcard Filtering</h2>
                  
                    <p>In this lesson, you‚Äôll learn what wildcards are, how they are used, and how to perform wildcard searches using the LIKE operator for more flexible filtering.</p>
                  
                    <h3>Using the LIKE Operator</h3>
                    <p>Previous filtering methods used known values ‚Äî matching exact values or ranges. But sometimes, you want to find partial matches, such as all products containing the phrase "bean bag". This is where wildcard searching helps.</p>
                  
                    <p><strong>Wildcards:</strong> Special characters used to match parts of a value.</p>
                    <p><strong>Search pattern:</strong> A search condition using literal text, wildcard characters, or both.</p>
                  
                    <p>To use wildcards, you must use the <code>LIKE</code> operator. LIKE tells the database to perform a pattern match, not just a direct comparison.</p>
                  
                    <h3>The Percent Sign (%) Wildcard</h3>
                    <p>The percent sign (%) matches any number of characters. For example, to find all products starting with the word ‚ÄúFish‚Äù:</p>
                  
                    <h4>Input</h4>
                    <pre class="code"><code>SELECT prod_id, prod_name
                  FROM Products
                  WHERE prod_name LIKE 'Fish%';</code></pre>
                  
                    <p><strong>Analysis:</strong><br>
                    This retrieves any value that starts with ‚ÄúFish‚Äù. The percent sign (%) matches any trailing characters.</p>
                  
                    <h3>The Underscore (_) Wildcard</h3>
                    <p>The underscore (_) matches exactly one character. For example, to match "12 inch teddy bear" or "18 inch teddy bear":</p>
                  
                    <h4>Input</h4>
                    <pre class="code"><code>SELECT prod_id, prod_name
                  FROM Products
                  WHERE prod_name LIKE '__ inch teddy bear';</code></pre>
                  
                    <p>This matches any product name where the first two characters can be anything, followed by " inch teddy bear".</p>
                  
                    <h3>The Brackets ([]) Wildcard</h3>
                    <p>The brackets wildcard allows you to specify a list or range of characters to match at a specific position in the string. Example syntax:</p>
                    <pre class="code"><code>WHERE prod_name LIKE '[FBR]%'</code></pre>
                    <p>This matches any product name starting with F, B, or R.</p>
                  
                    <h3>Tips for Using Wildcards</h3>
                    <ul>
                      <li>‚úÖ Use wildcards only when necessary; they are slower than exact match filters.</li>
                      <li>‚ö†Ô∏è Avoid starting patterns with a wildcard unless needed ‚Äî these are the slowest to process.</li>
                      <li>üéØ Be precise ‚Äî misplaced wildcards can lead to incorrect results.</li>
                    </ul>
                  
                    <p>Used wisely, wildcards are a powerful part of your SQL toolkit.</p>
                  
                    <h3>Summary</h3>
                    <p>In this lesson, you learned how to use SQL wildcards ‚Äî %, _, and [] ‚Äî in WHERE clauses with the LIKE operator. While powerful, wildcards should be used with care for performance and accuracy.</p>
                  
                  
              
                   
                        <h2 id="lesson-7">Lesson 7: Creating Calculated Fields</h2>
                      
                        <h3>Understanding Calculated Fields</h3>
                        <p>Data in a database is not always in the exact format your application needs. Common examples include:</p>
                        <ul>
                          <li>Combining company name and location from separate fields</li>
                          <li>Formatting address lines by joining city, state, and ZIP</li>
                          <li>Changing case (e.g., all uppercase)</li>
                          <li>Computing total prices from quantity √ó item_price</li>
                          <li>Performing totals, averages, or calculations directly in queries</li>
                        </ul>
                      
                        <p>Rather than reformat data in the application, you can retrieve calculated or reformatted values directly from SQL queries using <strong>calculated fields</strong>.</p>
                      
                        <p>Calculated fields don‚Äôt exist in the table‚Äîthey are created on-the-fly using expressions inside the <code>SELECT</code> statement.</p>
                      
                        <p><strong>Concatenate:</strong> Joining values together (appending them) into one combined value.</p>
                      
                        <p>To concatenate fields in SQL, you use:</p>
                        <ul>
                          <li><code>+</code> or <code>||</code> in many databases</li>
                          <li><code>CONCAT()</code> in MySQL or MariaDB</li>
                        </ul>
                      
                        <p>The <code>RTRIM()</code> function can be used to trim trailing spaces for cleaner output.</p>
                      
                        <h3>Using Aliases</h3>
                        <p>Calculated fields do not have a name by default. To make them usable in client applications, assign them a name using the <code>AS</code> keyword.</p>
                      
                        <p><strong>Tip: Other Uses for Aliases</strong><br>
                        Aliases are useful for renaming columns with special characters, making column names more readable, or resolving ambiguity in joins.</p>
                      
                        <h3>Performing Mathematical Calculations</h3>
                      
                        <h4>Input</h4>
                        <pre class="code"><code>SELECT prod_id,
                             quantity,
                             item_price,
                             quantity * item_price AS expanded_price
                      FROM OrderItems
                      WHERE order_num = 20008;</code></pre>
                      
                        <h4>Output</h4>
                        <pre class="code"><code>prod_id   quantity   item_price   expanded_price
                      RGAN01    5          4.9900       24.9500
                      BR03      5          11.9900      59.9500
                      BNBG01    10         3.4900       34.9000
                      BNBG02    10         3.4900       34.9000</code></pre>
                      
                        <p><strong>Analysis</strong><br>
                        The <code>expanded_price</code> column is calculated using <code>quantity * item_price</code>. It behaves like any regular column in output and can be used in reports, exports, or applications.</p>
                      
                        <h3>Summary</h3>
                        <p>In this lesson, you learned how to create calculated fields in SQL for string concatenation and math. You also saw how to use aliases to name these fields for easier use in applications.</p>
                      
                      
      
                        
                            <h2 id="lesson-8">Lesson 8: Using Data Manipulation Functions</h2>
                          
                            <h3>Understanding Functions</h3>
                            <p>In this lesson, you‚Äôll learn what functions are, the types of functions supported by SQL DBMSs, and the advantages and challenges of using them effectively.</p>
                          
                            <p><strong>Functions</strong> are built-in operations provided by SQL databases to transform or analyze data values within queries.</p>
                          
                            <h3>Types of SQL Functions</h3>
                            <ul>
                              <li><strong>Text functions</strong>: Manipulate string values (e.g., trimming, padding, case conversion)</li>
                              <li><strong>Numeric functions</strong>: Perform math operations on numeric data (e.g., absolute value, rounding)</li>
                              <li><strong>Date and time functions</strong>: Handle date/time values, extract parts, or calculate differences</li>
                              <li><strong>System functions</strong>: Return info about the DBMS or session (e.g., current user, server time)</li>
                            </ul>
                          
                            <h3>Text Manipulation Functions</h3>
                            <p>In Lesson 7, we used <code>RTRIM()</code> to remove trailing white space. Here's another example using <code>UPPER()</code> to convert text to uppercase:</p>
                          
                            <h4>Input</h4>
                            <pre class="code"><code>SELECT prod_name, UPPER(prod_name) AS uppercase_name
                          FROM Products;</code></pre>
                          
                            <p>This query returns the product name in its original form and in uppercase.</p>
                          
                            <h3>Date and Time Manipulation Functions</h3>
                            <p>Dates and times are stored in special formats depending on the DBMS. SQL provides powerful functions to work with these values, such as extracting year, calculating differences, and formatting output.</p>
                          
                            <p>However, date and time functions are the least standardized ‚Äî each DBMS handles them differently.</p>
                          
                            <p>Here's an example that retrieves all orders made in the year 2012 using SQL Server:</p>
                          
                            <h4>Input</h4>
                            <pre class="code"><code>SELECT order_num, order_date
                          FROM Orders
                          WHERE YEAR(order_date) = 2012;</code></pre>
                          
                            <p>This query extracts the year from each <code>order_date</code> and filters those equal to 2012.</p>
                          
                            <h3>Summary</h3>
                            <p>In this lesson, you learned how to use SQL functions to manipulate data:</p>
                            <ul>
                              <li>Text functions like <code>UPPER()</code> and <code>RTRIM()</code></li>
                              <li>Date and time functions like <code>YEAR()</code></li>
                              <li>SQL functions are powerful but can vary across DBMSs ‚Äî always test on your specific platform</li>
                            </ul>

                            <h2 id="lesson-9">Lesson 9. Summarizing Data</h2>

<p>It is often necessary to summarize data without actually retrieving it all, and SQL provides special functions for this purpose. Using these functions, SQL queries are often used to retrieve data for analysis and reporting purposes.</p>

<p>Examples of this type of retrieval are:</p>
<ul>
  <li>Determining the number of rows in a table (or the number of rows that meet some condition or contain a specific value).</li>
  <li>Obtaining the sum of a set of rows in a table.</li>
  <li>Finding the highest, lowest, and average values in a table column (either for all rows or for specific rows).</li>
</ul>

<p>In each of these examples, you want a summary of the data in a table, not the actual data itself. Therefore, returning the actual table data would be a waste of time and processing resources (not to mention bandwidth). To repeat, all you really want is the summary information.</p>

<p>To facilitate this type of retrieval, SQL features a set of five aggregate functions:</p>

<table border="1">
  <thead>
    <tr><th>Function</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td>AVG()</td><td>Return a column's average value</td></tr>
    <tr><td>COUNT()</td><td>Return the number of rows in a column</td></tr>
    <tr><td>MAX()</td><td>Return a column's highest value</td></tr>
    <tr><td>MIN()</td><td>Return a column's lowest value</td></tr>
    <tr><td>SUM()</td><td>Return the sum of a column's values</td></tr>
  </tbody>
</table>

<h3>The AVG() Function</h3>
<p>AVG() is used to return the average value of a specific column by counting both the number of rows in the table and the sum of their values. AVG() can be used to return the average value of all columns or of specific columns or rows.</p>

<h4>Individual Columns Only</h4>
<p>AVG() may only be used to determine the average of a specific numeric column, and that column name must be specified as the function parameter. To obtain the average value of multiple columns, multiple AVG() functions must be used.</p>

<h3>The COUNT() Function</h3>
<p>COUNT() does just that: It counts. Using COUNT(), you can determine the number of rows in a table or the number of rows that match a specific criterion.</p>
<p>COUNT() can be used two ways:</p>
<ul>
  <li>Use <code>COUNT(*)</code> to count the number of rows in a table, whether columns contain values or NULL values.</li>
  <li>Use <code>COUNT(column)</code> to count the number of rows that have values in a specific column, ignoring NULL values.</li>
</ul>

<h4>NOTE: NULL Values</h4>
<p>Column rows with NULL values in them are ignored by the COUNT() function if a column name is specified, but not if the asterisk (*) is used.</p>

<h3>The MAX() Function</h3>
<p>MAX() returns the highest value in a specified column. MAX() requires that the column name be specified.</p>

<h4>TIP: Using MAX() with Non-Numeric Data</h4>
<p>Although MAX() is usually used to find the highest numeric or date values, many (but not all) DBMSs allow it to be used to return the highest value in any columns including textual columns. When used with textual data, MAX() returns the row that would be the last if the data were sorted by that column.</p>

<h4>Note: NULL Values</h4>
<p>Column rows with NULL values in them are ignored by the MAX() function.</p>

<h3>The MIN() Function</h3>
<p>MIN() does the exact opposite of MAX(); it returns the lowest value in a specified column. Like MAX(), MIN() requires that the column name be specified.</p>

<h3>The SUM() Function</h3>
<p>SUM() is used to return the sum (total) of the values in a specific column.</p>
<p>Here is an example to demonstrate this. The <code>OrderItems</code> table contains the actual items in an order, and each item has an associated quantity. The total number of items ordered (the sum of all the quantity values) can be retrieved:</p>

<h4>Input</h4>
<pre><code>SELECT SUM(quantity) AS items_ordered
FROM OrderItems
WHERE order_num = 20005;
</code></pre>

<h3>Aggregates on Distinct Values</h3>
<p>The five aggregate functions can all be used in two ways:</p>
<ul>
  <li>To perform calculations on all rows, specify the <code>ALL</code> argument or specify no argument at all (because ALL is the default behavior).</li>
  <li>To only include unique values, specify the <code>DISTINCT</code> argument.</li>
</ul>

<h4>Caution: No DISTINCT With COUNT(*)</h4>
<p><code>DISTINCT</code> may only be used with <code>COUNT()</code> if a column name is specified. DISTINCT may not be used with <code>COUNT(*)</code>. Similarly, DISTINCT must be used with a column name and not with a calculation or expression.</p>

<h4>Tip: Using DISTINCT with MIN() and MAX()</h4>
<p>Although DISTINCT can technically be used with MIN() and MAX(), there is actually no value in doing so. The minimum and maximum values in a column will be the same whether or not only distinct values are included.</p>

<h3>Combining Aggregate Functions</h3>
<p>All the examples of aggregate function used thus far have involved a single function. But actually, SELECT statements may contain as few or as many aggregate functions as needed. Look at this example:</p>

<h4>Input</h4>
<pre><code>SELECT COUNT(*) AS num_items,
       MIN(prod_price) AS price_min,
       MAX(prod_price) AS price_max,
       AVG(prod_price) AS price_avg
FROM Products;
</code></pre>

<p>Here a single SELECT statement performs four aggregate calculations in one step and returns four values (the number of items in the Products table, and the highest, lowest, and average product prices).</p>

<h4>Caution: Naming Aliases</h4>
<p>When specifying alias names to contain the results of an aggregate function, try to not use the name of an actual column in the table. Although there is nothing actually illegal about doing so, many SQL implementations do not support this and will generate obscure error messages if you do so.</p>

<h3>Summary</h3>
<p>Aggregate functions are used to summarize data. SQL supports five aggregate functions, all of which can be used in multiple ways to return just the results you need. These functions are designed to be highly efficient, and they usually return results far more quickly than you could calculate them yourself within your own client application.</p>



<section>
  <h2 id="lesson-10">Lesson 10: Grouping Data</h2>

  <h3>Tips</h3>
  <ul>
    <li>Use <code>GROUP BY</code> to group rows and perform aggregate functions on those groups.</li>
    <li>Use <code>HAVING</code> to filter <strong>groups</strong> (after grouping), unlike <code>WHERE</code> which filters <strong>rows</strong> (before grouping).</li>
    <li>Every column in <code>SELECT</code> that's not an aggregate must be in the <code>GROUP BY</code> clause.</li>
    <li>Always use <code>ORDER BY</code> if you want sorted results‚Äî<code>GROUP BY</code> alone won‚Äôt guarantee sorting.</li>
    <li>Be cautious using aliases in <code>GROUP BY</code>‚Äîmany DBMSs don‚Äôt support it.</li>
    <li>Microsoft Access doesn't allow <code>ORDER BY</code> aliasing. Use actual calculation or column position instead.</li>
  </ul>

  <h3>Input</h3>
  <pre><code>SELECT vend_id, COUNT(*) AS num_prods
FROM Products
GROUP BY vend_id;
  </code></pre>

  <h3>Output</h3>
  <pre>
vend_id   | num_prods
---------------------
BRS01     | 3
DLL01     | 4
FNG01     | 2
  </pre>

  <h3>Analysis</h3>
  <p>
    This counts how many products each vendor has.<br>
    <code>GROUP BY vend_id</code> groups the products table by vendor.<br>
    <code>COUNT(*)</code> is then calculated <strong>per group</strong>.<br>
    <code>vend_id</code> is not repeated; the output is <strong>one row per group</strong>.
  </p>

  <h3>Filtering Groups with HAVING</h3>

  <h4>Example Input</h4>
  <pre><code>SELECT vend_id, COUNT(*) AS num_prods
FROM Products
WHERE prod_price >= 4
GROUP BY vend_id
HAVING COUNT(*) >= 2;
  </code></pre>

  <h4>Output</h4>
  <pre>
vend_id   | num_prods
---------------------
BRS01     | 3
FNG01     | 2
  </pre>

  <h4>Analysis</h4>
  <p>
    <code>WHERE</code> filters rows with <code>prod_price >= 4</code>.<br>
    Then <code>GROUP BY</code> groups by vendor.<br>
    Finally, <code>HAVING</code> filters groups having at least <strong>2</strong> products.
  </p>

  <h3>GROUP BY vs ORDER BY</h3>
  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>Feature</th>
        <th>GROUP BY</th>
        <th>ORDER BY</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Purpose</td>
        <td>Groups rows</td>
        <td>Sorts the final output</td>
      </tr>
      <tr>
        <td>Column Use</td>
        <td>Only columns in <code>SELECT</code> or expressions</td>
        <td>Any columns (even non-selected)</td>
      </tr>
      <tr>
        <td>Required?</td>
        <td>Required for aggregates</td>
        <td>Optional</td>
      </tr>
    </tbody>
  </table>

  <h3>Final Example with Sorting</h3>

  <h4>Input</h4>
  <pre><code>SELECT order_num, COUNT(*) AS items
FROM OrderItems
GROUP BY order_num
HAVING COUNT(*) >= 3
ORDER BY items, order_num;
  </code></pre>

  <h4>Output</h4>
  <pre>
order_num | items
-----------------
20006     | 3
20009     | 3
20007     | 5
20008     | 5
  </pre>

  <h4>Analysis</h4>
  <p>
    <code>GROUP BY</code> groups by <code>order_num</code> to count items.<br>
    <code>HAVING</code> filters orders with 3 or more items.<br>
    <code>ORDER BY</code> sorts by item count, then order number.
  </p>
</section>


<section>
  <h2 id="lesson-11">Lesson 11: Working with Subqueries</h2>

  <p>In this lesson, you‚Äôll learn what subqueries are and how to use them.</p>

  <p>
    <strong>SELECT</strong> statements are SQL queries. All the SELECT statements we have seen thus far are simple queries:
    single statements retrieving data from individual database tables.
  </p>

  <h3>Query</h3>
  <p><strong>Query:</strong> Any SQL statement. However, the term is usually used to refer to SELECT statements.</p>

  <p>
    SQL also enables you to create <strong>subqueries</strong>: queries that are embedded into other queries. Why would
    you want to do this? The best way to understand this concept is to look at a couple of examples.
  </p>

  <h3>Caution: Single Column Only</h3>
  <p>
    Subquery SELECT statements can only retrieve a single column. Attempting to retrieve multiple columns will return an error.
  </p>

  <h3>Caution: Subqueries and Performance</h3>
  <p>
    The code shown here works, and it achieves the desired result. However, using subqueries is not always the most
    efficient way to perform this type of data retrieval. More on this in Lesson 12, ‚ÄúJoining Tables,‚Äù where you will
    revisit this same example.
  </p>

  <h3>Summary</h3>
  <p>
    In this lesson, you learned what subqueries are and how to use them. The most common uses for subqueries are in
    WHERE clause IN operators and for populating calculated columns. You saw examples of both of these types of
    operations.
  </p>
</section>
<div id="Problem and soultion on Joins"><h2>Problem and soultion on Joins</h2>
<p>
  <section>
  
  1.From the following tables write a SQL query to list all salespersons along with customer name, city, grade, order number, date, and amount. Condition for selecting list of salesmen : 1. Salesmen who works for one or more customer or, 2. Salesmen who not yet join under any customer, Condition for selecting list of customer : 3. placed one or more orders, or 4. no order placed to their salesman.
  </section>
  </p>   
  <p>
  <em> sampple table </em> : "customer"
  </p>
  
  <pre>
   customer_id |   cust_name    |    city    | grade | salesman_id 
  -------------+----------------+------------+-------+-------------
          3002 | Nick Rimando   | New York   |   100 |        5001
          3007 | Brad Davis     | New York   |   200 |        5001
          3005 | Graham Zusi    | California |   200 |        5002
          3008 | Julian Green   | London     |   300 |        5002
          3004 | Fabian Johnson | Paris      |   300 |        5006
          3009 | Geoff Cameron  | Berlin     |   100 |        5003
          3003 | Jozy Altidor   | Moscow     |   200 |        5007
          3001 | Brad Guzan     | London     |       |        5005
  
  </pre>
  
  <p>
  <em> sampple table </em> : "salesman"
  </p>
  
  <pre>
   salesman_id |    name    |   city   | commission 
  -------------+------------+----------+------------
          5001 | James Hoog | New York |       0.15
          5002 | Nail Knite | Paris    |       0.13
          5005 | Pit Alex   | London   |       0.11
          5006 | Mc Lyon    | Paris    |       0.14
          5007 | Paul Adam  | Rome     |       0.13
          5003 | Lauson Hen | San Jose |       0.12
  
  </pre>
  
  
  <p>
  <em> sampple table </em> : "order"
  </p>
  
  <pre>
  ord_no      purch_amt   ord_date    customer_id  salesman_id
  ----------  ----------  ----------  -----------  -----------
  70001       150.5       2012-10-05  3005         5002
  70009       270.65      2012-09-10  3001         5005
  70002       65.26       2012-10-05  3002         5001
  70004       110.5       2012-08-17  3009         5003
  70007       948.5       2012-09-10  3005         5002
  70005       2400.6      2012-07-27  3007         5001
  70008       5760        2012-09-10  3002         5001
  70010       1983.43     2012-10-10  3004         5006
  
  </pre>
  
  
  
  <pre>
  <code>
  -- Selecting specific columns and renaming one column for clarity
  SELECT a.cust_name, a.city, a.grade, 
         b.name AS "Salesman", 
         c.ord_no, c.ord_date, c.purch_amt 
  -- Specifying the tables to retrieve data from ('customer' as 'a', 'salesman' as 'b', and 'orders' as 'c')
  FROM customer a 
  -- Performing a right outer join based on the salesman_id, including unmatched rows from 'salesman'
  RIGHT OUTER JOIN salesman b 
  ON b.salesman_id = a.salesman_id 
  -- Performing another right outer join with the result of the previous join and the 'orders' table based on customer_id
  RIGHT OUTER JOIN orders c 
  ON c.customer_id = a.customer_id;
  </code>
  </pre>
  
  
  
  
  <p>2. Write a SQL statement to generate a list in ascending order of salespersons who work either for one or more customers or have not yet joined any of the customers.</p>
  <p><em>Sample table</em>: customer </p>
  <pre style="overflow: scroll; height: 150px;">
   customer_id |   cust_name    |    city    | grade | salesman_id 
  -------------+----------------+------------+-------+-------------
          3002 | Nick Rimando   | New York   |   100 |        5001
          3007 | Brad Davis     | New York   |   200 |        5001
          3005 | Graham Zusi    | California |   200 |        5002
          3008 | Julian Green   | London     |   300 |        5002
          3004 | Fabian Johnson | Paris      |   300 |        5006
          3009 | Geoff Cameron  | Berlin     |   100 |        5003
          3003 | Jozy Altidor   | Moscow     |   200 |        5007
          3001 | Brad Guzan     | London     |       |        5005
  </pre>	 
  <p><em>Sample table</em>: salesman</p>
  <pre style="overflow: scroll; height: 100px;">
   salesman_id |    name    |   city   | commission 
  -------------+------------+----------+------------
          5001 | James Hoog | New York |       0.15
          5002 | Nail Knite | Paris    |       0.13
          5005 | Pit Alex   | London   |       0.11
          5006 | Mc Lyon    | Paris    |       0.14
          5007 | Paul Adam  | Rome     |       0.13
          5003 | Lauson Hen | San Jose |       0.12
  </pre>		
  <p><strong>Sample Solution:</strong></p>
  <pre class="line-numbers">
  <code class="language-sql">-- Selecting specific columns and renaming them for clarity
  SELECT a.cust_name, a.city, a.grade, 
         b.name AS "Salesman", b.city 
  -- Specifying the tables to retrieve data from ('customer' as 'a' and 'salesman' as 'b')
  FROM customer a 
  -- Performing a right outer join based on the salesman_id, including unmatched rows from 'salesman'
  RIGHT OUTER JOIN salesman b 
  ON b.salesman_id = a.salesman_id 
  -- Sorting the result set by salesman_id in ascending order
  ORDER BY b.salesman_id; 
  </code></pre>
  <p>Output of the Query:</p>
  <pre>
  cust_name	city		grade	Salesman	city
  Brad Davis	New York	200	James Hoog	New York
  Nick Rimando	New York	100	James Hoog	New York
  Graham Zusi	California	200	Nail Knite	Paris
  Julian Green	London		300	Nail Knite	Paris
  Geoff Cameron	Berlin		100	Lauson Hen	San Jose
  Brad Guzan	London			Pit Alex	London
  Fabian Johnson	Paris		300	Mc Lyon		Paris
  Jozy Altidor	Moscow		200	Paul Adam	Rome
  </pre>
  <p><strong>Explanation:</strong></p>
  <p>The said SQL query is performing a right outer join on the customer table alias a and the salesman table alias b on the 'salesman_id' column. It is then selecting the 'cust_name', 'city', and 'grade' columns from the customer table, and the 'name' and 'city' columns from the salesman table. The result is ordered by the 'salesman_id' column.<br>
  This query will select all the rows from the salesman table and any matching rows from the customer table and returning the results in the order of salesman_id. If there is no match, it will return NULL for the non-matching columns of customer table.</p>
  
  
  
  
  
  <p class="p_h1">3.Order & Salesperson Report</p>
  <p>SQL statement to generate a report with customer name, city, order number, order date, order amount, salesperson name, and commission to determine if any of the existing customers have not placed orders or if they have placed orders through their salesman or by themselves.</p>
  <p><em>Sample table</em>: customer</p>
  <pre style="overflow: scroll; height: 150px;">
   customer_id |   cust_name    |    city    | grade | salesman_id 
  -------------+----------------+------------+-------+-------------
          3002 | Nick Rimando   | New York   |   100 |        5001
          3007 | Brad Davis     | New York   |   200 |        5001
          3005 | Graham Zusi    | California |   200 |        5002
          3008 | Julian Green   | London     |   300 |        5002
          3004 | Fabian Johnson | Paris      |   300 |        5006
          3009 | Geoff Cameron  | Berlin     |   100 |        5003
          3003 | Jozy Altidor   | Moscow     |   200 |        5007
          3001 | Brad Guzan     | London     |       |        5005
  </pre>	 		 
  <p><em>Sample table</em>: orders</p>
  <pre style="overflow: scroll; height: 150px;">
  ord_no      purch_amt   ord_date    customer_id  salesman_id
  ----------  ----------  ----------  -----------  -----------
  70001       150.5       2012-10-05  3005         5002
  70009       270.65      2012-09-10  3001         5005
  70002       65.26       2012-10-05  3002         5001
  70004       110.5       2012-08-17  3009         5003
  70007       948.5       2012-09-10  3005         5002
  70005       2400.6      2012-07-27  3007         5001
  70008       5760        2012-09-10  3002         5001
  70010       1983.43     2012-10-10  3004         5006
  70003       2480.4      2012-10-10  3009         5003
  70012       250.45      2012-06-27  3008         5002
  70011       75.29       2012-08-17  3003         5007
  70013       3045.6      2012-04-25  3002         5001
  </pre>	  	
  <p><em>Sample table</em>: salesman</p>
  <pre style="overflow: scroll; height: 100px;">
   salesman_id |    name    |   city   | commission 
  -------------+------------+----------+------------
          5001 | James Hoog | New York |       0.15
          5002 | Nail Knite | Paris    |       0.13
          5005 | Pit Alex   | London   |       0.11
          5006 | Mc Lyon    | Paris    |       0.14
          5007 | Paul Adam  | Rome     |       0.13
          5003 | Lauson Hen | San Jose |       0.12
  </pre>	
  <p><strong>Sample Solution:</strong></p>
  <pre class="line-numbers">
  <code class="language-sql">-- Selecting specific columns and renaming one column for clarity
  SELECT a.cust_name, a.city, b.ord_no,
         b.ord_date, b.purch_amt AS "Order Amount", 
         c.name, c.commission 
  -- Specifying the tables to retrieve data from ('customer' as 'a', 'orders' as 'b', and 'salesman' as 'c')
  FROM customer a 
  -- Performing a left outer join based on the customer_id, including unmatched rows from 'customer'
  LEFT OUTER JOIN orders b 
  ON a.customer_id = b.customer_id 
  -- Performing another left outer join with the result of the previous join and the 'salesman' table based on salesman_id
  LEFT OUTER JOIN salesman c 
  ON c.salesman_id = b.salesman_id;
  </code></pre>
  <p>Output of the Query:</p>
  <pre class="output">
  cust_name	city		ord_no	ord_date	Order Amount	name		commission
  Brad Guzan	London		70009	2012-09-10	270.65		Pit Alex	0.11
  Nick Rimando	New York	70002	2012-10-05	65.26		James Hoog	0.15
  Geoff Cameron	Berlin		70004	2012-08-17	110.50		Lauson Hen	0.12
  Brad Davis	New York	70005	2012-07-27	2400.60		James Hoog	0.15
  Nick Rimando	New York	70008	2012-09-10	5760.00		James Hoog	0.15
  Fabian Johnson	Paris		70010	2012-10-10	1983.43		Mc Lyon		0.14
  Geoff Cameron	Berlin		70003	2012-10-10	2480.40		Lauson Hen	0.12
  Jozy Altidor	Moscow		70011	2012-08-17	75.29		Paul Adam	0.13
  Nick Rimando	New York	70013	2012-04-25	3045.60		James Hoog	0.15
  Graham Zusi	California	70001	2012-10-05	150.50		Nail Knite	0.13
  Graham Zusi	California	70007	2012-09-10	948.50		Nail Knite	0.13
  Julian Green	London		70012	2012-06-27	250.45		Nail Knite	0.13
  </pre>
  <p><strong>Explanation:</strong></p>
  <p>The said SQL query is selecting the customer name, city, order number, order date, purchase amount, salesman name and commission from 3 tables customer aliased as a, orders aliased as b, and salesman aliased as c. It is joining these tables on the 'customer_id' and 'salesman_id' column respectively. <br>
  Additionally, it is using two LEFT OUTER JOINs, which will retrieve all records from the left table and the matching records from the right table. If no match is found on the right table, it will return NULL for the right table's fields.<br> 
  This query will retrieve all customer details, order details and salesman details along with their commission even if some customer or salesman doesn't have any orders.</p>
  
  
  
  
  
  <p class="p_h1">27.	Employee Name & Department Sanction</p>
  <p>From the following tables write a SQL query to display the first and last names of each employee, as well as the department name and sanction amount.</p>
  <p><em>Sample table</em>: emp_department</p>
  <!--<div class="row-fluid">
   <iframe src ="emp_department.php" height="175" class="span12"></iframe>
  </div><br>-->
  <pre style="overflow: scroll; height: 100px;">
  DPT_CODE DPT_NAME        DPT_ALLOTMENT
  -------- --------------- -------------
        57 IT                      65000
        63 Finance                 15000
        47 HR                     240000
        27 RD                      55000
        89 QC                      75000
  </pre>
  
  <p><em>Sample table</em>: emp_details </p>
  <!--<div class="row-fluid">
  <iframe src ="emp_details.php" height="175" class="span12"></iframe>
  </div><br>-->
  <pre style="overflow: scroll; height: 150px;">
   EMP_IDNO EMP_FNAME       EMP_LNAME         EMP_DEPT
  --------- --------------- --------------- ----------
     127323 Michale         Robbin                  57
     526689 Carlos          Snares                  63
     843795 Enric           Dosio                   57
     328717 Jhon            Snares                  63
     444527 Joseph          Dosni                   47
     659831 Zanifer         Emily                   47
     847674 Kuleswar        Sitaraman               57
     748681 Henrey          Gabriel                 47
     555935 Alex            Manuel                  57
     539569 George          Mardy                   27
     733843 Mario           Saule                   63
     631548 Alan            Snappy                  27
     839139 Maria           Foster                  57
  </pre>	
  <p><strong>Sample Solution:</strong></p>
  <pre class="line-numbers">
  <code class="language-sql">-- Selecting specific columns and renaming them for clarity
  SELECT emp_details.emp_fname AS "First Name", emp_lname AS "Last Name", 
         emp_department.dpt_name AS "Department", 
         dpt_allotment AS "Amount Allotted"
  -- Specifying the tables to retrieve data from ('emp_details' and 'emp_department')
  FROM emp_details 
  -- Performing an inner join based on the equality of 'emp_dept' in 'emp_details' and 'dpt_code' in 'emp_department'
  INNER JOIN emp_department
  ON emp_details.emp_dept = emp_department.dpt_code;
  </code></pre>
  
  <p>Output of the Query:</p>
  <pre class="output" style="overflow: scroll">
  First Name	Last Name	Department	Amount Allotted
  Alan		Snappy		RD		55000
  Maria		Foster		IT		65000
  Michale		Robbin		IT		65000
  Carlos		Snares		Finance		15000
  Enric		Dosio		IT		65000
  Jhon		Snares		Finance		15000
  Joseph		Dosni		HR		240000
  Zanifer		Emily		HR		240000
  Kuleswar	Sitaraman	IT		65000
  Henrey		Gabriel		HR		240000
  Alex		Manuel		IT		65000
  George		Mardy		RD		55000
  Mario		Saule		Finance		15000
  </pre>
  <p><strong>Explanation:</strong></p>
  <p>The said SQL query is selecting the employee's first name (emp_details.emp_fname) with an alias 'First Name', last name (emp_lname) with an alias 'Last Name', department name (emp_department.dpt_name) with an alias 'Department', and department allotment (dpt_allotment) with an alias 'Amount Allotted' by joining the emp_details table and emp_department table on the emp_dept column of the emp_details table and the dpt_code column of the emp_department table. The query is joining the two tables together and displaying the selected columns from both tables.</p>
  <p><hr>
  </div>

  <div class="input-analysis" style="font-family: 'Courier New', monospace; font-weight: bold; font-size: 1.2em; color: #2c3e50; margin-bottom: 20px;">
    Input Analysis: Lesson 14
  </div>

  <h2 id="Lesson 14: combining queries">COMBINING QUERIES</h2>

  <p>Most SQL queries contain a single <code>SELECT</code> statement that returns data from one or more tables. SQL also enables you to perform multiple queries (multiple <code>SELECT</code> statements) and return the results as a single query result set. These combined queries are usually known as unions or compound queries.</p>

  <p>SQL queries are combined using the <code>UNION</code> operator. Using <code>UNION</code>, multiple <code>SELECT</code> statements can be specified, and their results can be combined into a single result set.</p>

  <h3>UNION Rules</h3>

  <p>As you can see, unions are very easy to use. But there are a few rules governing exactly which can be combined:</p>

  <ul>
    <li>A <code>UNION</code> must be composed of two or more <code>SELECT</code> statements, each separated by the keyword <code>UNION</code> (so, if combining four <code>SELECT</code> statements there would be three <code>UNION</code> keywords used).</li>
    <li>Each query in a <code>UNION</code> must contain the same columns, expressions, or aggregate functions (and some DBMSs even require that columns be listed in the same order).</li>
    <li>Column datatypes must be compatible: They need not be the exact same type, but they must be of a type that the DBMS can implicitly convert (for example, different numeric types or different date types).</li>
  </ul>

  <h3>Including or Eliminating Duplicate Rows</h3>

  <p>The <code>UNION</code> automatically removes any duplicate rows from the query result. This is the default behavior of <code>UNION</code>, but you can change this if you so desire. If you would, in fact, want all occurrences of all matches returned, you can use <code>UNION ALL</code> instead of <code>UNION</code>.</p>

  <h3>Sorting Combined Query Results</h3>

  <p><code>SELECT</code> statement output is sorted using the <code>ORDER BY</code> clause. When combining queries with a <code>UNION</code> only one <code>ORDER BY</code> clause may be used, and it must occur after the final <code>SELECT</code> statement. There is very little point in sorting part of a result set one way and part another way, and so multiple <code>ORDER BY</code> clauses are not allowed.</p>

  <h3>Summary</h3>

  <p>In this lesson, you learned how to combine <code>SELECT</code> statements with the <code>UNION</code> operator. Using <code>UNION</code>, you can return the results of multiple queries as one combined query, either including or excluding duplicates. The use of <code>UNION</code> can greatly simplify complex <code>WHERE</code> clauses and retrieving data from multiple tables.</p>

  <div class="input-analysis" style="font-family: 'Courier New', monospace; font-weight: bold; font-size: 1.2em; color: #2c3e50; margin-bottom: 20px;">
    Lesson 15
  </div>

  <h2 id="lesson 15:inserting data">INSERTING DATA</h2>

  <h3>Understanding Data Insertion</h3>

  <p><code>SELECT</code> is undoubtedly the most frequently used SQL statement (which is why the last 14 lessons were dedicated to it). But there are three other frequently used SQL statements that you should learn. The first one is <code>INSERT</code>. (You‚Äôll get to the other two in the next lesson.)</p>

  <p>As its name suggests, <code>INSERT</code> is used to insert (add) rows to a database table. <code>INSERT</code> can be used in several ways:</p>

  <ul>
    <li>Inserting a single complete row</li>
    <li>Inserting a single partial row</li>
    <li>Inserting the results of a query</li>
  </ul>

  <h3>Inserting Complete Rows</h3>

  <p>The simplest way to insert data into a table is to use the basic <code>INSERT</code> syntax, which requires that you specify the table name and the values to be inserted into the new row. Here is an example of this:</p>

  <h4>Input</h4>
  <pre><code>
INSERT INTO Customers
VALUES('1000000006',
       'Toy Land',
       '123 Any Street',
       'New York',
       'NY',
       '11111',
       'USA',
       NULL,
       NULL);
  </code></pre>

  <h4>Analysis</h4>
  <p>This example inserts a new customer into the <code>Customers</code> table. The data to be stored in each table column is specified in the <code>VALUES</code> clause, and a value must be provided for every column. If a column has no value, use <code>NULL</code> (assuming the table allows it). The columns must be populated in the order they appear in the table definition.</p>

  <p>Although simple, this syntax is not safe because it's highly dependent on the column order. Writing SQL that assumes a specific column order is dangerous and should be avoided.</p>

  <p>The safer way is:</p>

  <h4>Input</h4>
  <pre><code>
INSERT INTO Customers(cust_id,
                      cust_name,
                      cust_address,
                      cust_city,
                      cust_state,
                      cust_zip,
                      cust_country,
                      cust_contact,
                      cust_email)
VALUES('1000000006',
       'Toy Land',
       '123 Any Street',
       'New York',
       'NY',
       '11111',
       'USA',
       NULL,
       NULL);
  </code></pre>

  <h4>Analysis</h4>
  <p>This example does the same as the previous one, but explicitly lists the column names. The DBMS matches the values to the columns based on position, not name.</p>

  <h3>Inserting Partial Rows</h3>
  <p>When using <code>INSERT</code>, it's recommended to specify column names explicitly. This allows you to omit columns you don't want to provide values for.</p>

  <h3>Inserting Retrieved Data</h3>
  <p><code>INSERT</code> is often used with fixed values, but you can also insert data retrieved from another table using <code>INSERT SELECT</code>. For example:</p>

  <h4>Input</h4>
  <pre><code>
INSERT INTO Customers(cust_id,
                      cust_contact,
                      cust_email,
                      cust_name,
                      cust_address,
                      cust_city,
                      cust_state,
                      cust_zip,
                      cust_country)
SELECT cust_id,
       cust_contact,
       cust_email,
       cust_name,
       cust_address,
       cust_city,
       cust_state,
       cust_zip,
       cust_country
FROM CustNew;
  </code></pre>

  <h4>Tip: Column Names in INSERT SELECT</h4>
  <p>The column names in <code>INSERT</code> and <code>SELECT</code> don't need to match. The DBMS matches values by position, not name.</p>

  <h4>Analysis</h4>
  <p>This inserts all rows from <code>CustNew</code> into <code>Customers</code>. If <code>CustNew</code> has rows, they are inserted; if it‚Äôs empty, nothing happens.</p>

  <h4>Tip: Inserting Multiple Rows</h4>
  <p><code>INSERT</code> normally adds one row at a time, unless used with <code>INSERT SELECT</code>, which can insert multiple rows in one go.</p>

  <h3>Copying from One Table to Another</h3>
  <p>Another method of data insertion uses <code>SELECT INTO</code> to copy data into a new table:</p>

  <h4>Input</h4>
  <pre><code>
SELECT *
INTO CustCopy
FROM Customers;
  </code></pre>

  <h4>Analysis</h4>
  <p>This creates a new table <code>CustCopy</code> and copies all data from <code>Customers</code>. To copy only specific columns, list them instead of using <code>*</code>.</p>

  <p>In MariaDB, MySQL, Oracle, PostgreSQL, and SQLite:</p>

  <h4>Input</h4>
  <pre><code>
CREATE TABLE CustCopy AS
SELECT * FROM Customers;
  </code></pre>

  <p>Notes on <code>SELECT INTO</code>:</p>
  <ul>
    <li>All <code>SELECT</code> options like <code>WHERE</code>, <code>GROUP BY</code> can be used.</li>
    <li>You can join multiple tables.</li>
    <li>Only one table can be created with <code>SELECT INTO</code>.</li>
  </ul>

  <h3>Summary</h3>
  <p>You learned how to <code>INSERT</code> rows into a table, the benefits of specifying columns explicitly, and how to use <code>INSERT SELECT</code> and <code>SELECT INTO</code> to copy data. The next lesson covers <code>UPDATE</code> and <code>DELETE</code> for modifying data.</p>                      
  
  <h1 id = "Lesson 16: Updating and Deleting Data">Lesson 16: Updating and Deleting Data</h1>

  <h2>UPDATE Statement</h2>
  <p>The <strong>UPDATE</strong> statement is used to modify existing data in a table.</p>

  <h3>Syntax</h3>
  <pre><code>UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
</code></pre>

  <h3>Example</h3>
  <pre><code>UPDATE Customers
SET cust_email = 'kim@thetoystore.com'
WHERE cust_id = '1000000005';
</code></pre>

  <h3>Updating Multiple Columns</h3>
  <pre><code>UPDATE Customers
SET cust_contact = 'Sam Roberts',
    cust_email = 'sam@toyland.com'
WHERE cust_id = '1000000006';
</code></pre>

  <h3>Setting a Column to NULL</h3>
  <pre><code>UPDATE Customers
SET cust_email = NULL
WHERE cust_id = '1000000005';
</code></pre>

  <p class="warning">Important: Always use a WHERE clause to avoid updating all rows unintentionally.</p>

  <h2>DELETE Statement</h2>
  <p>The <strong>DELETE</strong> statement is used to remove rows from a table.</p>

  <h3>Syntax</h3>
  <pre><code>DELETE FROM table_name
WHERE condition;
</code></pre>

  <h3>Example</h3>
  <pre><code>DELETE FROM Customers
WHERE cust_id = '1000000006';
</code></pre>

  <p class="warning">Be careful: Omitting the WHERE clause deletes all rows from the table.</p>

  <h2>TRUNCATE TABLE</h2>
  <ul>
    <li>Deletes all rows in a table.</li>
    <li>Faster than DELETE because it doesn't log individual row deletions.</li>
    <li>Does not delete the table itself.</li>
  </ul>
  <pre><code>TRUNCATE TABLE Customers;
</code></pre>

  <h2>Guidelines and Best Practices</h2>
  <ul>
    <li>Never execute UPDATE or DELETE without a WHERE clause unless you're sure.</li>
    <li>Ensure every table has a primary key and use it in your WHERE clause.</li>
    <li>Test your WHERE clause with SELECT first to confirm correct filtering.</li>
    <li>Use referential integrity to prevent deleting rows that are referenced in other tables.</li>
    <li>Consider DBMS-level restrictions to prevent unsafe UPDATE or DELETE commands.</li>
  </ul>

  <div class="note">
    <strong>Note:</strong> SQL does not have an Undo function. Be very cautious when using UPDATE and DELETE.
  </div>


  <h1 id ="Lesson 17: Creating and Manipulating Tables">Lesson 17: Creating and Manipulating Tables</h1>

  <h2>Creating Tables</h2>
  <p>There are generally two ways to create database tables:</p>
  <ul>
    <li>Using a database administration tool provided by most DBMSs.</li>
    <li>Using SQL statements directly, such as <code>CREATE TABLE</code>.</li>
  </ul>

  <h3>Basic <code>CREATE TABLE</code> Syntax</h3>
  <p>You must specify:</p>
  <ul>
    <li>Table name after <code>CREATE TABLE</code>.</li>
    <li>Column names and definitions separated by commas.</li>
    <li>Some DBMSs may require the table location.</li>
  </ul>

  <h3>Example</h3>
  <pre><code>CREATE TABLE Products (
  prod_id     CHAR(10),
  vend_id     CHAR(10),
  prod_name   CHAR(50),
  prod_price  DECIMAL(8,2),
  prod_desc   TEXT
);</code></pre>

  <div class="note">
    The table name is placed right after <code>CREATE TABLE</code>, and all columns are defined inside parentheses. Each column is defined with its name and data type.
  </div>

  <div class="tip">
    <strong>Tip:</strong> SQL does not allow overwriting existing tables. You must first remove the existing table using <code>DROP TABLE</code> before creating a new one with the same name.
  </div>

  <h2>Specifying Default Values</h2>
  <p>Use the <code>DEFAULT</code> keyword in a column definition to set a default value when none is provided during <code>INSERT</code>.</p>

  <h3>Example</h3>
  <pre><code>CREATE TABLE OrderItems (
  order_num    INTEGER       NOT NULL,
  order_item   INTEGER       NOT NULL,
  prod_id      CHAR(10)      NOT NULL,
  quantity     INTEGER       NOT NULL DEFAULT 1,
  item_price   DECIMAL(8,2)  NOT NULL
);</code></pre>

  <div class="note">
    In this example, the <code>quantity</code> column has a default value of 1, so if a value is not provided, the DBMS will use 1 by default.
  </div>

  <h2>Updating Tables</h2>
  <p>Use <code>ALTER TABLE</code> to update a table definition. Support for specific alterations varies by DBMS.</p>

  <h3>Considerations</h3>
  <ul>
    <li>Ideally, avoid altering tables that already contain data.</li>
    <li>Most DBMSs support adding columns, but may restrict the datatypes or default values.</li>
    <li>Many do not allow removing or changing columns.</li>
    <li>Renaming columns is supported by most DBMSs.</li>
    <li>Fewer restrictions apply to unpopulated columns.</li>
  </ul>

  <h3>Example: Adding a Column</h3>
  <pre><code>ALTER TABLE Vendors
ADD vend_phone CHAR(20);</code></pre>

  <div class="caution">
    <strong>Caution:</strong> Always back up your schema and data before using <code>ALTER TABLE</code>. Mistakes may be irreversible.
  </div>

  <h2>Deleting Tables</h2>
  <p>To remove an entire table, use <code>DROP TABLE</code>.</p>

  <h3>Example</h3>
  <pre><code>DROP TABLE CustCopy;</code></pre>

  <div class="caution">
    Deleting a table permanently removes its structure and data. Proceed carefully.
  </div>

  <h2>Summary</h2>
  <p>This lesson covered how to:</p>
  <ul>
    <li>Use <code>CREATE TABLE</code> to define new tables.</li>
    <li>Use <code>ALTER TABLE</code> to modify table definitions.</li>
    <li>Use <code>DROP TABLE</code> to delete tables.</li>
  </ul>
  <p>Always consult your specific DBMS documentation, as syntax and supported features may vary.</p>

  <h3 id="Understanding Views">Understanding Views</h3>
  <p>Views are virtual tables that dynamically retrieve data using stored queries.</p>

  <h3>Why Use Views</h3>
  <ul>
    <li>Reuse SQL statements</li>
    <li>Simplify complex queries</li>
    <li>Restrict access to table subsets</li>
    <li>Secure data</li>
    <li>Change data formatting</li>
  </ul>

  <h3>View Rules and Restrictions</h3>
  <ul>
    <li>Must have unique names</li>
    <li>Unlimited number can be created</li>
    <li>Require appropriate security access</li>
    <li>Can be nested (check DBMS limits)</li>
    <li>ORDER BY often not allowed in views</li>
    <li>Aliases may be required for calculated fields</li>
    <li>Cannot have indexes, triggers, or defaults</li>
    <li>Often read-only (depends on DBMS)</li>
  </ul>

  <h3>Creating Views</h3>

  <h4>Example: Simplify Complex Joins</h4>
  <pre><code>CREATE VIEW ProductCustomers AS
SELECT cust_name, cust_contact, prod_id
FROM Customers, Orders, OrderItems
WHERE Customers.cust_id = Orders.cust_id
AND OrderItems.order_num = Orders.order_num;</code></pre>

  <pre><code>SELECT cust_name, cust_contact
FROM ProductCustomers
WHERE prod_id = 'RGAN01';</code></pre>

  <h4>Example: Reformat Retrieved Data</h4>
  <pre><code>CREATE VIEW VendorLocations AS
SELECT RTRIM(vend_name) || ' (' || RTRIM(vend_country) || ')'
AS vend_title
FROM Vendors;</code></pre>

  <pre><code>SELECT * FROM VendorLocations;</code></pre>



  <!-- Lesson 19: Stored Procedures -->
  <section id="lesson19">
    <h2>Lesson 19: Using Stored Procedures</h2>

    <h3>What are Stored Procedures?</h3>
    <p>
      A <strong>stored procedure</strong> is a saved block of SQL code that performs a specific task.
      It is stored in the database and can be executed (called) multiple times without rewriting SQL.
    </p>

    <h3>Advantages of Stored Procedures</h3>
    <ul>
      <li>Improves performance by reducing parsing and compilation</li>
      <li>Promotes code reuse and modularity</li>
      <li>Enhances security by controlling access to data</li>
      <li>Can include complex business logic</li>
      <li>Helps centralize SQL code and improve maintainability</li>
    </ul>

    <h3>Creating Stored Procedures</h3>
    <pre><code>DELIMITER $$

CREATE PROCEDURE GetCustomerEmailList()
BEGIN
  SELECT cust_name, cust_email
  FROM Customers
  WHERE cust_email IS NOT NULL;
END$$

DELIMITER ;</code></pre>

    <p>
      This procedure, <code>GetCustomerEmailList</code>, returns all customers with non-null email addresses.
    </p>

    <h3>Calling Stored Procedures</h3>
    <pre><code>CALL GetCustomerEmailList();</code></pre>

    <h3>Using Parameters</h3>
    <pre><code>CREATE PROCEDURE GetOrdersByCustomer(IN cust_id_param CHAR(10))
BEGIN
  SELECT order_num, order_date
  FROM Orders
  WHERE cust_id = cust_id_param;
END;</code></pre>

    <p>
      This version of the procedure accepts a customer ID as input and returns their orders.
    </p>

    <pre><code>CALL GetOrdersByCustomer('1001');</code></pre>

    <h3>Summary</h3>
    <ul>
      <li>Stored procedures encapsulate SQL logic</li>
      <li>Support input/output parameters</li>
      <li>Can simplify repetitive database tasks</li>
    </ul>
  </section>

  <hr />

  <!-- Lesson 20: Using Cursors -->
  <section id="lesson20">
    <h2>Lesson 20: Using Cursors</h2>

    <h3>What is a Cursor?</h3>
    <p>
      A <strong>cursor</strong> is a database object used to retrieve a set of rows and process them one at a time.
      Cursors are useful in stored procedures and functions when row-by-row processing is required.
    </p>

    <h3>When to Use Cursors</h3>
    <ul>
      <li>When set-based operations (standard SQL queries) are not sufficient</li>
      <li>When you need to perform complex operations on each row</li>
    </ul>

    <h3>Types of Cursors</h3>
    <ul>
      <li><strong>Implicit Cursor:</strong> Automatically created by SQL statements like SELECT INTO</li>
      <li><strong>Explicit Cursor:</strong> Declared and managed manually</li>
    </ul>

    <h3>Steps to Use an Explicit Cursor</h3>
    <ol>
      <li>Declare the cursor</li>
      <li>Open the cursor</li>
      <li>Fetch rows from the cursor</li>
      <li>Close the cursor</li>
    </ol>

    <h3>Cursor Example</h3>
    <pre><code>DELIMITER $$

CREATE PROCEDURE ListProductNames()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE prod_name_val VARCHAR(100);
  DECLARE prod_cursor CURSOR FOR SELECT prod_name FROM Products;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN prod_cursor;

  read_loop: LOOP
    FETCH prod_cursor INTO prod_name_val;
    IF done THEN
      LEAVE read_loop;
    END IF;
    SELECT prod_name_val;
  END LOOP;

  CLOSE prod_cursor;
END$$

DELIMITER ;</code></pre>

    <p>
      This procedure opens a cursor to read all product names one-by-one and prints each name.
    </p>

    <h3>Important Notes</h3>
    <ul>
      <li>Always use a <code>HANDLER</code> to manage end-of-data conditions</li>
      <li>Make sure to close cursors to free resources</li>
    </ul>

    <h3>Summary</h3>
    <ul>
      <li>Cursors are used for row-wise processing</li>
      <li>Explicit cursors give full control over reading a result set</li>
      <li>Use loops and handlers for safe and complete cursor logic</li>
    </ul>
  </section>





</body>
  
</html>
